const AOP_PATTERN = Symbol('AopPattern');
const AOP_HOOKS = Symbol('AopHooks');
const AOP_STATIC_ALLOW = Symbol('AopStaticAllow');
const AOP_FILTER_FUNCTION = Symbol('AopFilterFunction');

function invokePattern(pattern, meta) {
  if (!pattern) {
    return;
  }

  if (Array.isArray(pattern)) {
    return pattern.map((rule) => {
      return Reflect.apply(rule, rule.context, [meta]);
    });
  } else {
    const method = typeof pattern === 'function' ? pattern : pattern.method;
    return Reflect.apply(method, pattern.context, [meta]);
  }
}

function isConstructable(func) {
  return !!(func && func.prototype && func.prototype.constructor);
}

function createCallTrap({
  target,
  object,
  property,
  pattern,
  context,
  method,
}) {
  function callTrap(...rest) {
    const self = this;
    let payload = undefined;
    let meta = {};

    callTrap[AOP_HOOKS].forEach(
      ({ target, object, property, pattern, context }) => {
        invokePattern(pattern.beforeMethod, {
          target,
          object,
          property,
          context: context || self,
          args: rest,
          meta,
        });
      }
    );

    {
      const { target, object, property, pattern, context } =
        callTrap[AOP_HOOKS][callTrap[AOP_HOOKS].length - 1];
      const aroundPattern = Array.isArray(pattern.aroundMethod)
        ? pattern.aroundMethod[pattern.aroundMethod.length - 1]
        : pattern.aroundMethod;

      if (aroundPattern) {
        payload = invokePattern(aroundPattern, {
          target,
          object,
          property,
          context: context || self,
          args: rest,
          original:
            typeof object[property] === 'function' ? object[property] : method,
          meta,
        });
      } else {
        const { object, property, context } =
          callTrap[AOP_HOOKS][callTrap[AOP_HOOKS].length - 1];

        if (object && typeof object[property] === 'function') {
          if (property === 'constructor' && isConstructable(object)) {
            payload = Reflect.construct(object, rest);
          } else {
            payload = Reflect.apply(object[property], context || self, rest);
          }
        } else {
          payload = Reflect.apply(method, context || self, rest);
        }
      }
    }

    callTrap[AOP_HOOKS].forEach(
      ({ target, object, property, pattern, context }) => {
        invokePattern(pattern.afterMethod, {
          target,
          object,
          property,
          context: context || self,
          args: rest,
          payload,
          meta,
        });
      }
    );

    return payload;
  }

  callTrap[AOP_HOOKS] = [{ target, object, property, pattern, context }];

  return callTrap;
}

function createHook(name, regular, callback) {
  function hook(meta) {
    return hookFor(meta, regular, callback);
  }

  hook[AOP_FILTER_FUNCTION] = function ({ property, target, prototype }) {
    return (
      (typeof regular === 'string' && property.includes(regular)) ||
      (regular instanceof RegExp && regular.test(property)) ||
      (typeof regular === 'function' &&
        regular({ property, target, name, prototype }))
    );
  };

  return {
    [name]: hook,
  };
}

function hookFor(meta, regular, callback) {
  if (typeof regular === 'string') {
    if (meta.property.includes(regular)) {
      return callback(meta);
    }

    return null;
  }
  if (regular instanceof RegExp) {
    if (regular.test(meta.property)) {
      return callback(meta);
    }

    return null;
  }

  if (typeof regular === 'function') {
    if (regular(meta)) {
      return callback(meta);
    }

    return null;
  }

  if (Array.isArray(regular)) {
    return regular.map(({ rule, action }) => {
      return hookFor(meta, rule, action || callback);
    });
  }

  throw new TypeError(
    `Invalid rule type ${typeof regular}. Method accept string, regexp, function and array.`
  );
}

function hasToRegisterHook(hooks) {
  return (pattern, props) => {
    return hooks.reduce((result, hook) => {
      return (
        result ||
        (pattern[hook] &&
          typeof pattern[hook][AOP_FILTER_FUNCTION] === 'function' &&
          pattern[hook][AOP_FILTER_FUNCTION](props))
      );
    }, false);
  };
}

const hookName = Object.freeze({
  beforeMethod: 'beforeMethod',
  afterMethod: 'afterMethod',
  aroundMethod: 'aroundMethod',
  beforeGetter: 'beforeGetter',
  afterGetter: 'afterGetter',
  aroundGetter: 'aroundGetter',
  beforeSetter: 'beforeSetter',
  afterSetter: 'afterSetter',
  aroundSetter: 'aroundSetter',
});

const hasToRegisterMethodHook = hasToRegisterHook([
  hookName.beforeMethod,
  hookName.afterMethod,
  hookName.aroundMethod,
]);

function overOwnProperty({ target, pattern, original, object }) {
  Object.entries(Object.getOwnPropertyDescriptors(object)).forEach(function ([
    property,
  ]) {
    try {
      if (!hasToRegisterMethodHook(pattern, { property, target, object })) {
        original[property] = object[property];
        return;
      }

      if (property in original) {
        return;
      }

      if (!object[property]) {
        return;
      }

      let aopHooks = object[property][AOP_HOOKS];
      if (aopHooks) {
        const { object: lastObject } = aopHooks[aopHooks.length - 1];
        aopHooks.push({
          target,
          object: lastObject,
          property,
          pattern,
        });

        if (!(property in original)) {
          original[property] = () => {};
        }

        return;
      }

      if (
        typeof object[property] === 'function' &&
        !isConstructable(object[property])
      ) {
        original[property] = object[property];
        object[property] = createCallTrap({
          target,
          object: original,
          property,
          pattern,
        });
      }
    } catch (_) {
      //console.warn(`The '${property}' property is not hooked.`, _);
    } // eslint-disable-line no-empty
  });
}

function aopForMethods(target, pattern) {
  let original = {};
  let prototype = target.prototype;
  while (prototype) {
    overOwnProperty({ target, pattern, original, object: prototype });

    prototype = Reflect.getPrototypeOf(prototype);
  }
}

function createGetTrap({
  target,
  object,
  property,
  pattern,
  context,
  method,
}) {
  function getTrap() {
    const hasProperty = getTrap[AOP_HOOKS].reduce(
      (result, { object, property }) => {
        return result && Reflect.has(object, property);
      },
      true
    );

    if (!hasProperty) {
      return;
    }

    let payload = undefined;
    let meta = {};

    getTrap[AOP_HOOKS].forEach(
      ({ target, object, property, pattern, context }) => {
        invokePattern(pattern.beforeGetter, {
          target,
          object,
          property,
          context,
          meta,
        });
      }
    );

    const { target, object, property, pattern, context } =
      getTrap[AOP_HOOKS][getTrap[AOP_HOOKS].length - 1];
    const aroundGetter = Array.isArray(pattern.aroundGetter)
      ? pattern.aroundGetter[pattern.aroundGetter.length - 1]
      : pattern.aroundGetter;

    payload = aroundGetter
      ? invokePattern(aroundGetter, {
          target,
          object,
          property,
          context,
          meta,
        })
      : Reflect.get(object, property);

    getTrap[AOP_HOOKS].forEach(
      ({ target, object, property, pattern, context }) => {
        invokePattern(pattern.afterGetter, {
          target,
          object,
          property,
          context,
          payload,
          meta,
        });
      }
    );

    if (typeof payload === 'function') {
      payload = createCallTrap({
        target,
        object,
        property,
        pattern,
        context,
        method,
      });
    }

    return payload;
  }

  getTrap[AOP_HOOKS] = [{ target, object, property, pattern, context }];

  return getTrap;
}

function createSetTrap({
  target,
  object,
  property,
  pattern,
  context,
}) {
  function setTrap(payload) {
    let meta = {};

    setTrap[AOP_HOOKS].forEach(
      ({ target, object, property, context, pattern }) => {
        invokePattern(pattern.beforeSetter, {
          target,
          object,
          property,
          payload,
          context,
          meta,
        });
      }
    );

    const { target, object, property, pattern, context } =
      setTrap[AOP_HOOKS][setTrap[AOP_HOOKS].length - 1];
    const aroundSetter = Array.isArray(pattern.aroundSetter)
      ? pattern.aroundSetter[pattern.aroundSetter.length - 1]
      : pattern.aroundSetter;

    let result = aroundSetter
      ? invokePattern(aroundSetter, {
          target,
          object,
          property,
          payload,
          context,
          meta,
        })
      : Reflect.set(object, property, payload);

    setTrap[AOP_HOOKS].forEach(
      ({ target, object, property, context, pattern }) => {
        invokePattern(pattern.afterSetter, {
          target,
          object,
          property,
          payload,
          context,
          meta,
        });
      }
    );

    return result;
  }

  setTrap[AOP_HOOKS] = [{ target, object, property, pattern, context }];

  return setTrap;
}

const hasToRegisterGetterSetterHook = hasToRegisterHook([
  hookName.beforeGetter,
  hookName.afterGetter,
  hookName.aroundGetter,
  hookName.beforeSetter,
  hookName.afterSetter,
  hookName.aroundSetter,
]);

function aopForStatic(target, pattern) {
  let original = {};
  let originalTarget = target;

  if (!Object.prototype.hasOwnProperty.call(originalTarget, AOP_STATIC_ALLOW)) {
    Reflect.defineProperty(originalTarget, AOP_STATIC_ALLOW, {
      value: false,
      enumerable: false,
      writable: true,
    });
  } else {
    originalTarget[AOP_STATIC_ALLOW] = false;
  }

  while (target && target !== Function.prototype) {
    // TODO improve
    Object.entries(Object.getOwnPropertyDescriptors(target)).forEach(
      ([property, descriptor]) => {
        if (
          typeof descriptor.get === 'function' ||
          typeof descriptor.set === 'function'
        ) {
          if (Object.prototype.hasOwnProperty.call(original, property)) {
            return;
          }

          Reflect.defineProperty(original, property, descriptor);
          if (
            !hasToRegisterGetterSetterHook(pattern, {
              target,
              property,
              object: original,
            })
          ) {
            return;
          }

          Reflect.defineProperty(
            target,
            property,
            Object.assign({}, descriptor, {
              get: (...rest) => {
                if (originalTarget[AOP_STATIC_ALLOW] === true) {
                  let aopHooks = descriptor.get[AOP_HOOKS];
                  if (aopHooks) {
                    const { object } = aopHooks[aopHooks.length - 1];

                    aopHooks.push({
                      target,
                      object,
                      property,
                      pattern,
                    });

                    return typeof descriptor.get === 'function'
                      ? descriptor.get(...rest)
                      : undefined;
                  }

                  return createGetTrap({
                    target,
                    object: original,
                    property,
                    pattern,
                  })(...rest);
                } else {
                  return typeof descriptor.get === 'function'
                    ? descriptor.get(...rest)
                    : undefined;
                }
              },
              set: (payload) => {
                if (originalTarget[AOP_STATIC_ALLOW] === true) {
                  return createSetTrap({
                    target,
                    object: original,
                    property,
                    pattern,
                  })(payload);
                }
              },
            })
          );
        }
      }
    );

    overOwnProperty({ target, pattern, original, object: target });
    target = Reflect.getPrototypeOf(target);
  }

  originalTarget[AOP_STATIC_ALLOW] = true;
}

function createProxy(target, pattern, context) {
  pattern = pattern || target[AOP_PATTERN] || {};

  const proxy = new Proxy(target, {
    get(object, property) {
      let original = object[property];
      let value = createGetTrap({ target, object, property, pattern })();

      if (value === undefined || original === undefined) {
        return;
      }

      if (typeof original !== 'object' && typeof original !== 'function') {
        return value;
      }

      return createProxy(original, pattern, object);
    },
    set(object, property, payload) {
      return createSetTrap({ target, object, property, pattern })(payload);
    },
    apply(method, object, args) {
      return createCallTrap({
        target,
        object: context || object,
        property: method.name,
        pattern,
        context: context || object,
        method,
      })(...args);
    },
  });

  return proxy;
}

function createAspect(pattern) {
  return function applyAop(target) {
    return aop(target, pattern);
  };
}

function aop(target, pattern, settings = { constructor: false }) {
  if (settings && settings.constructor && typeof target === 'function') {
    return aopWithConstructor(target, pattern);
  }

  return applyAop(target, pattern);
}

function aopWithConstructor(target, pattern) {
  let prototype = target.prototype;

  function AOPConstructor(...rest) {
    return createCallTrap({
      target,
      object: target,
      property: 'constructor',
      pattern,
      context: this,
    })(...rest);
  }

  AOPConstructor.prototype = prototype;

  applyAop(AOPConstructor, pattern);

  return AOPConstructor;
}

function unAop(target) {
  if (target[AOP_PATTERN]) {
    target[AOP_PATTERN] = Object.keys(target[AOP_PATTERN]).reduce(
      (pattern, hookName) => {
        pattern[hookName] = undefined;

        return pattern;
      },
      target[AOP_PATTERN]
    );

    target[AOP_PATTERN] = undefined;
  }
}

function applyAop(target, pattern) {
  if (target[AOP_PATTERN]) {
    if (typeof target === 'function') {
      aopForStatic(target, pattern);
      aopForMethods(target, pattern);

      return;
    }

    mergePattern(target, pattern);

    return;
  }

  Reflect.defineProperty(target, AOP_PATTERN, {
    value: Object.assign({}, pattern),
    enumerable: false,
    writable: true,
  });

  if (typeof target === 'function') {
    return applyAopToClass(target);
  }

  if (typeof target === 'object') {
    return applyAopToInstance(target);
  }

  throw new TypeError(
    `aop accept only object and class. You gave type of ${typeof target}.`
  );
}

function applyAopToInstance(instance) {
  return createProxy(instance);
}

function applyAopToClass(target) {
  let pattern = target[AOP_PATTERN];

  aopForStatic(target, pattern);
  aopForMethods(target, pattern);
}

function mergePattern(target, pattern) {
  let currentTargetPattern = target[AOP_PATTERN];

  target[AOP_PATTERN] = Object.entries(pattern).reduce(
    (resultPattern, [hookName, hookValue]) => {
      if (!resultPattern[hookName]) {
        resultPattern = hookName;
      }

      if (resultPattern[hookName]) {
        if (!Array.isArray(resultPattern[hookName])) {
          resultPattern[hookName] = [resultPattern[hookName]];
        }
        if (!Array.isArray(hookValue)) {
          hookValue = [hookValue];
        }

        resultPattern[hookName] = resultPattern[hookName].concat(hookValue);
      }

      return resultPattern;
    },
    currentTargetPattern
  );
}

export { aop, createAspect, createCallTrap, createGetTrap, createHook, createProxy, createSetTrap, hookFor, hookName, unAop };
